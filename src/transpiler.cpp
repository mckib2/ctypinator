#include <sstream>
#include <fstream>
#include <iostream>
#include <map>

#include "clang/AST/ASTConsumer.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/FrontendAction.h"
#include "clang/Frontend/FrontendActions.h"
#include "clang/Tooling/Tooling.h"
#include "llvm/IR/DerivedTypes.h"

#include "no_python_keywords.hpp"

using namespace clang;

class CTypesVisitor : public RecursiveASTVisitor<CTypesVisitor> {
public:
  explicit CTypesVisitor(ASTContext *Context)
    : Context(Context)
    , used_ndpointer(false)
    , used_complex_float(false)
    , used_complex_double(false)
    {}

  bool VisitFunctionDecl(FunctionDecl *Declaration) {

    std::ostringstream func_decls;
    std::ostringstream paramlist;
    std::size_t ii = 0; // iteration number
    func_decls << "    _lib." << Declaration->getNameAsString()
               << ".restype = "
               << typemap(Declaration->getReturnType())
               << "\n";
    func_wrappers << "def " << Declaration->getNameAsString() << "(";
    func_decls << "    _lib." << Declaration->getNameAsString()
               << ".argtypes = [";
    for (auto it = Declaration->param_begin(); it != Declaration->param_end(); ++it) {
      func_decls << typemap((*it)->getOriginalType());
      if ((*it)->getNameAsString() != "") {
        // Use the parameter's name if we have it;
        // extra "_" at end to deconflict any Python keywords
        func_wrappers << cleanPythonKeywords((*it)->getNameAsString());
        paramlist << cleanPythonKeywords((*it)->getNameAsString());
      }
      else {
        func_wrappers << "arg" << ii;
        paramlist << "arg" << ii;
      }
      func_wrappers << ": " << typemap((*it)->getOriginalType());
      if ((it+1) != Declaration->param_end()) {
        func_decls << ", ";
        func_wrappers << ", ";
        paramlist << ", ";
      }
      ++ii;
    }
    func_decls << "]" << "\n";
    func_wrappers << ") -> " << typemap(Declaration->getReturnType()) << ":" << "\n";
    func_wrappers << func_decls.str();
    func_wrappers << "    ";
    if (typemap(Declaration->getReturnType()) != "None") {
      func_wrappers << "return ";
    }
    func_wrappers << "_lib." << Declaration->getNameAsString()
                  << "(" << paramlist.str() << ")" << "\n\n";

    return true;
  }

  bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {
    return true;
  }

  void HandleStruct(CXXRecordDecl *Declaration, const std::string & name) {
    forward_decls << "class " << name << "(ctypes.Structure): pass" << "\n";

    if (Declaration->field_empty()) {
      global_decls << name << "._fields_ = []\n\n";
    }
    else {
      global_decls << name << "._fields_ = [" << "\n";
      for (const auto & f : Declaration->fields()) {
        global_decls << "    ('" << f->getNameAsString() << "', " << typemap(f->getType()) << " " << "),\n";
      }
      global_decls << "]\n\n";
    }
  }

  bool VisitTypedefNameDecl(TypedefNameDecl *Declaration) {
    if (auto a = llvm::dyn_cast<clang::ElaboratedType>(Declaration->getUnderlyingType())) {
      if (a->isStructureType()) {
        if (auto d = llvm::dyn_cast_or_null<clang::CXXRecordDecl>(a->getAsStructureType()->getDecl())) {
          if (d->getNameAsString() != "") {
            HandleStruct(d, d->getNameAsString());
          }
          else {
            HandleStruct(d, a->getNamedType().getAsString());
          }
        }
      }
    }
    return true;
  }

  void toString(const char *const libpath,
                const char *const outfile,
                const std::map<std::string, std::string>* macros) {
    std::ofstream myfile;
    myfile.open(outfile);
    myfile << "# NOTE: This file was autogenerated using cythonator." << "\n"
           << "#       Any changes will be overwritten upon regeneration." << "\n"
           << "\n"
           << "import ctypes\n";
    if (used_ndpointer) {
      myfile << "from numpy.ctypeslib import ndpointer\n";
    }
    if (used_complex_float) {
      myfile << "class Complex64(ctypes.Structure):\n"
             << "    _fields_ = [('real', ctypes.c_float), ('imag', ctypes.c_float)]\n";
    }
    if (used_complex_double) {
      myfile << "class Complex128(ctypes.Structure):\n"
             << "    _fields_ = [('real', ctypes.c_double), ('imag', ctypes.c_double)]\n";
    }
    myfile << "\n";

    // write all the macros we know about
    myfile << "# macros (if any)\n";
    for (const auto & kv : *macros) {
      myfile << kv.first << " = " << "'" << kv.second << "'\n";
    }

    // now do the wrappers
    myfile << "\n\n"
           << "# forward declaration of structs\n"
           << forward_decls.str()
           << "\n"
           << global_decls.str();

    myfile << "\n"
           << "# Load the shared library when the module is loaded\n"
           << "_lib = ctypes.cdll.LoadLibrary('" << libpath << "')\n"
           << "\n"
           << "# Function wrappers\n"
           << func_wrappers.str();
    myfile.close();
  }

protected:

  const std::string typemap(const clang::QualType& t) {

    static const std::map<std::string, std::string> _map {
      {"void", "None"},
      {"const char *", "ctypes.c_char_p"}, // special case of char*
      {"char *", "ctypes.c_char_p"}, // special case of char*
      {"char", "ctypes.c_char"},
      {"double", "ctypes.c_double"},
      {"long double", "ctypes.c_longdouble"},
      {"float", "ctypes.c_float"},
      {"int", "ctypes.c_int"},
      {"long", "ctypes.c_long"},
      {"long long", "ctypes.c_longlong"},
      {"short", "ctypes.c_short"},
      {"unsigned char", "ctypes.c_ubyte"},
      {"unsigned int", "ctypes.c_uint"},
      {"unsigned long", "ctypes.c_ulong"},
      {"unsigned long long", "ctypes.c_ulonglong"},
      {"unsigned short", "ctypes.c_ushort"},
      {"_Bool", "ctypes.c_bool"},
      {"void *", "ctypes.c_void_p"},
      {"_Complex float *", "ndpointer(np.complex64, flags='C')"},
      {"_Complex double *", "ndpointer(np.complex128, flags='C')"}
    };

    std::string cmp_t = t.getAsString();

    // Remove const qualifiers:
    if (cmp_t.rfind("const ", 0) == 0) {
      cmp_t = cmp_t.substr(6);
    }

    // Remove struct keyword
    if (cmp_t.rfind("struct ", 0) == 0) {
      cmp_t = cmp_t.substr(7);
    }

    // Simple cases:
    if (_map.count(cmp_t)) {
      return _map.at(cmp_t);
    }

    if (!t.getTypePtr()->isAnyPointerType()) {
      // non-pointer, fixed-size arrays
      if (auto a = llvm::dyn_cast_or_null<clang::ConstantArrayType>(t.getTypePtr())) {
        return _map.at(cmp_t.substr(0, cmp_t.find("[")-1)) + "*" + a->getSize().toString(/*radix=*/10, /*signed=*/false);
      }
      // non-pointer, incomplete-size arrays
      else {
        used_ndpointer = true;
        return "ndpointer(dtype=" + _map.at(cmp_t.substr(0, cmp_t.find("[")-1)) + ")";
      }
    }
    else if (t.getTypePtr()->isFunctionPointerType()) {
      // function pointer
      if(auto func = llvm::dyn_cast_or_null<clang::FunctionProtoType>(t.getTypePtr()->getPointeeType().getDesugaredType(*Context).getTypePtr())) {
        std::ostringstream params;
        for(const auto & p : func->getParamTypes()) {
          params << ", " << typemap(p);
        }
        return "ctypes.CFUNCTYPE(" + params.str().substr(2) + ")"; // remove leading comma
      }
      // TODO: support varargs?
      return "UNHANDLED FUNC POINTER";
    }
    else {
      // pointers, fixed_size arrays
      if (auto a = llvm::dyn_cast_or_null<clang::ConstantArrayType>(t.getTypePtr())) {
        return "ctypes.POINTER("
          + _map.at(cmp_t.substr(0, cmp_t.find("*")-1))
          + ")*" + a->getSize().toString(/*radix=*/10, /*signed=*/false);
      }

      // pointers, non-array
      std::string key = cmp_t.substr(0, cmp_t.find("*")-1);
      if (_map.count(key)) {
        return "ctypes.POINTER(" + _map.at(key) + ")";
      }

      // hail mary
      return "ctypes.POINTER(" + cmp_t.substr(0, cmp_t.find("*")-1) + ")";
    }

    // Replace base type
    std::size_t substr_sz = cmp_t.find("*");
    if (substr_sz == std::string::npos) {
      substr_sz = cmp_t.find("[");
    }
    if (substr_sz != std::string::npos) {
      std::string key = cmp_t.substr(0, substr_sz-1);
      if (_map.count(key)) {
        cmp_t = _map.at(key) + cmp_t.substr(substr_sz, cmp_t.size());
      }
      else {
        std::cout << "Could not find " << key << std::endl;
      }
    }

    // unwrap pointers
    return cmp_t;
  }


  // const std::string typemap(const clang::QualType & t) {
  //   std::ostringstream rtype;
  //   bool is_ptr = t.getTypePtr()->isAnyPointerType();
  //   bool is_ptr_ptr = is_ptr && t.getTypePtr()->getPointeeType().getDesugaredType(*Context).getTypePtr()->isAnyPointerType();
  //   bool is_func_ptr = t.getTypePtr()->isFunctionPointerType();
  //   bool is_arr = t.getTypePtr()->isArrayType();
  //   bool is_const_arr = is_arr && llvm::dyn_cast_or_null<clang::ConstantArrayType>(t.getTypePtr());
  //   // bool is_varr = is_arr && llvm::dyn_cast_or_null<clang::VariableArrayType>(t.getTypePtr());
  //   // bool is_dep_size_arr = is_arr && llvm::dyn_cast_or_null<clang::DependentSizedArrayType>(t.getTypePtr());
  //   bool is_incomplete_arr = is_arr && llvm::dyn_cast_or_null<clang::IncompleteArrayType>(t.getTypePtr());

  //   // consider some special cases
  //   // TODO: recursively resolve pointer of pointer
  //   if (is_ptr) {
  //     const std::string & _rtype = t.getAsString();
  //     if (_rtype == "const char *") {
  //       is_ptr = false;
  //     }
  //     else if (_rtype == "char *") {
  //       is_ptr = false;
  //     }
  //     else if (_rtype == "void *") {
  //       is_ptr = false;
  //     }

  //     if (is_func_ptr) {
  //       rtype << "ctypes.CFUNCTYPE(";
  //     }
  //     else if (is_ptr) {
  //       rtype << "ctypes.POINTER(";
  //     }
  //   }

  //   if (is_incomplete_arr) {
  //     rtype << "ndpointer(";
  //     used_ndpointer = true;
  //   }

  //   std::string cmp_t = is_ptr
  //     ? (is_func_ptr
  //        ? llvm::dyn_cast_or_null<clang::FunctionType>(t.getTypePtr()->getPointeeType().getDesugaredType(*Context).getTypePtr())->getReturnType().getAsString()
  //        : (is_ptr_ptr
  //           ? typemap(t.getTypePtr()->getPointeeType().getUnqualifiedType())
  //           : t.getTypePtr()->getPointeeType().getUnqualifiedType().getAsString()))
  //     : (is_const_arr
  //        ? llvm::dyn_cast_or_null<clang::ConstantArrayType>(t.getTypePtr())->getElementType().getUnqualifiedType().getAsString()
  //        : (is_incomplete_arr
  //           ? (llvm::dyn_cast_or_null<clang::IncompleteArrayType>(t.getTypePtr())->getElementType().getUnqualifiedType().isAnyPointerType(),
  //              ? llvm::dyn_cast_or_null<clang::IncompleteArrayType>(t.getTypePtr())->getElementType().getUnqualifiedType().getTypePtr()->getPointeeType().getUnqualifiedType().getAsString()
  //              : llvm::dyn_cast_or_null<clang::IncompleteArrayType>(t.getTypePtr())->getElementType().getUnqualifiedType().getAsString())
  //           : t.getUnqualifiedType().getAsString()));

  //   // hacky way remove const qualifier
  //   if ((cmp_t.rfind("const ", 0) == 0) && (cmp_t != "const char *")) {
  //     cmp_t = cmp_t.substr(6);
  //   }

  //   if (cmp_t == "void") {
  //     rtype << "None";
  //   }
  //   else if (cmp_t == "int") {
  //     rtype << "ctypes.c_int";
  //   }
  //   else if (cmp_t == "double") {
  //     rtype << "ctypes.c_double";
  //   }
  //   else if (cmp_t == "float") {
  //     rtype << "ctypes.c_float";
  //   }
  //   else if (cmp_t == "const char *" || cmp_t == "char *") {
  //     rtype << "ctypes.c_char_p";
  //   }
  //   else if (cmp_t == "void *") {
  //     rtype << "ctypes.c_void_p";
  //   }
  //   else if (cmp_t == "size_t") {
  //     rtype << "ctypes.c_size_t";
  //   }
  //   else if (cmp_t == "long") {
  //     rtype << "ctypes.c_long";
  //   }
  //   else if (cmp_t == "long long") {
  //     rtype << "ctypes.c_longlong";
  //   }
  //   else if (cmp_t == "long double") {
  //     rtype << "ctypes.c_longdouble";
  //   }
  //   else if (cmp_t == "unsigned int") {
  //     rtype << "ctypes.c_uint";
  //   }
  //   else if (cmp_t == "_Complex float") {
  //     rtype << "Complex64";
  //     used_complex_float = true;
  //   }
  //   else if (cmp_t == "va_list") {
  //     // TODO: this may not work in all cases
  //     rtype << "ctypes.c_void_p";
  //   }
  //   else {
  //     // hacky workaround for typedef'd structs
  //     if (cmp_t.rfind("struct ", 0) == 0) {
  //       rtype << cmp_t.substr(7);
  //     }
  //     else {
  //       rtype << cmp_t;
  //     }
  //   }

  //   // TODO: handle arguments
  //   if (is_func_ptr) {
  //     if(auto func = llvm::dyn_cast_or_null<clang::FunctionProtoType>(t.getTypePtr()->getPointeeType().getDesugaredType(*Context).getTypePtr())) {
  //       for(const auto & p : func->getParamTypes()) {
  //         rtype << ", " << typemap(p);
  //       }
  //       // TODO: support varargs?
  //     }
  //   }

  //   if (auto a = llvm::dyn_cast_or_null<clang::ConstantArrayType>(t.getTypePtr())) {
  //     rtype << "*" << a->getSize().toString(/*radix=*/10, /*signed=*/false);
  //   }
  //   if (auto a = llvm::dyn_cast_or_null<clang::IncompleteArrayType>(t.getTypePtr())) {
  //     rtype << ", flags='C_CONTIGUOUS')";
  //   }
  //   if (is_ptr || is_func_ptr) {
  //     rtype << ")";
  //   }

  //   return rtype.str();
  // }

private:
  ASTContext *Context;
  std::ostringstream func_wrappers;
  std::ostringstream forward_decls;
  std::ostringstream global_decls;
  bool used_ndpointer;
  bool used_complex_float;
  bool used_complex_double;
};

class TranspilationConsumer : public clang::ASTConsumer {
public:
  explicit TranspilationConsumer(ASTContext *Context,
                                 const char* libpath,
                                 const char* outfile,
                                 const std::map<std::string, std::string>* macros)
    : Visitor(Context)
    , libpath(libpath)
    , outfile(outfile)
    , macros(macros)
  {}

  virtual void HandleTranslationUnit(clang::ASTContext &Context) {
    Visitor.TraverseDecl(Context.getTranslationUnitDecl());
    Visitor.toString(libpath, outfile, macros);
  }
private:
  CTypesVisitor Visitor;
  const char *const libpath;
  const char *const outfile;
  const std::map<std::string, std::string>* macros;
};

class TranspilationAction : public clang::ASTFrontendAction {
public:
  TranspilationAction(const char *const libpath,
                      const char *const outfile,
                      const std::map<std::string, std::string>* macros)
    : libpath(libpath)
    , outfile(outfile)
    , macros(macros)
  {}
  virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(
        clang::CompilerInstance &Compiler, llvm::StringRef InFile) {
    return std::unique_ptr<clang::ASTConsumer>(
        new TranspilationConsumer(&Compiler.getASTContext(), libpath, outfile, macros));
  }
private:
  const char *const libpath;
  const char *const outfile;
  const std::map<std::string, std::string>* macros;
};

struct FindDefines : public clang::PPCallbacks {
  std::map<std::string, std::string>* macros;
  FindDefines(std::map<std::string, std::string>* macros) : macros(macros) {}
  virtual void MacroDefined(const Token &MacroNameTok,
                            const MacroDirective *MD) {
    switch (MD->getKind()) {
    case clang::MacroDirective::MD_Define:
      if (MD->isDefined()) {
        const MacroInfo* MI = MD->getMacroInfo();
        if (!MI->isFunctionLike()) {
          for (const auto & tok : MI->tokens()) {
            if (tok.isLiteral()) {
              // llvm::outs() << MacroNameTok.getIdentifierInfo()->getName()
              //              << ": " << tok.getName()
              //              << ": " << tok.getRawIdentifier() << "\n";
              macros->insert(std::make_pair(MacroNameTok.getIdentifierInfo()->getName().str(), tok.getRawIdentifier()));
            }
          }
        }
      }
      break;
    case clang::MacroDirective::MD_Undefine: break;
    case clang::MacroDirective::MD_Visibility: break;
    }
  }
};

struct DefineAction : public clang::PreprocessOnlyAction {
  std::map<std::string, std::string>* macros;
  DefineAction(std::map<std::string, std::string>* macros) : macros(macros) {}
  void ExecuteAction() {
    Preprocessor& pp = getCompilerInstance().getPreprocessor();
    pp.addPPCallbacks(std::make_unique<FindDefines>(macros));
    clang::PreprocessOnlyAction::ExecuteAction();
  }
};


extern "C" {
  void transpile(const char *const libpath, const char *const code, const char *const outfile) {
    std::vector<std::string> args {/*"-I/home/nicholas/Documents/bart/src/"*/};

    // Two passes:
    //     1) Preprocessor only to fill macros
    //     2) AST to construct wrappers
    std::map<std::string, std::string> macros;
    clang::tooling::runToolOnCode(std::make_unique<DefineAction>(&macros), code);
    clang::tooling::runToolOnCodeWithArgs(std::make_unique<TranspilationAction>(libpath, outfile, &macros),
                                          code, args, "input.cc", "ctypinator");
  }
}
